"""
Урок 8
15.12.2023

1. Сеты. Хеширование и рандом на практике (орел решка)
2. Методы сетов (анализ коллекции фильмов)
3. Знакомство со словарями

"""

# PRACTICE Орел Решка на сетах
"""
Подкидываем монетку через while и сеты
1. Сделайте переменную счетчик (опционально, это может быть пользовательским вводом - сколько хотите раз подкинуть монетку)
2. Сделайте цикл while пока счетчик меньше 10
3. Внутри цикла сделайте сет с 2 строками, орел, решка
4. Сделайте принт сет.pop и счетчик + 1
"""
# coin_set = {"орел", "решка"}
# print(coin_set.pop())
import random

THROUGHOUT = 100
coin_list = ["орел", "решка"]
# Счетчики орла и решки
eagle_count = 0
tails_count = 0

for i in range(THROUGHOUT):
    coin = random.choice(coin_list)
    if coin == "орел":
        eagle_count += 1
    else:
        tails_count += 1

    print(coin)

print(f"Орел: {eagle_count}, Решка: {tails_count}")

"""

Давайте разберем полную картину:

В Python строковые литералы (строки в кавычках) интернируются - это значит, что Python повторно использует уже созданные строки вместо создания новых копий. Когда вы пишете {'орел', 'решка'} много раз в цикле, Python не создает новые строки каждый раз, а использует ссылки на уже существующие.

Представьте это как колоду карт:

У вас есть две карты: Туз ♠️ (орел) и Король ♠️ (решка)
Каждый раунд вы:
Берете КОПИИ этих же самых карт (но это те же самые карты, просто новая колода)
Раскладываете их по тем же правилам (хеширование)
Туз всегда ложится слева, потому что его "вес" (хеш) меньше
Король всегда справа
Берете левую карту (pop берет первый элемент по хешу)
И получаете каждый раз Туза!

"""

a = 2.5
print(hash(a))  # 1152921504606846978

b = 4
print(hash(b))  # 4

c = "asfasf1dfsdf#)*"
print(hash(c))  # -2640635771081213618


# Методы сетов
"""
add(item) - добавляет элемент в множество
clear() - удаляет все элементы из множества
copy() - возвращает копию множества
difference(set) - или оператор - возвращает разницу между множествами
difference_update(set) - или оператор -= удаляет элементы из множества, которые есть во втором множестве
discard(item) - удаляет элемент из множества, если он там есть
intersection(set) - или оператор & возвращает пересечение множеств
intersection_update(set) - или оператор &= обновляет множество, оставляя только элементы, которые есть в обоих множествах
isdisjoint(set) - возвращает True, если множества не имеют общих элементов
issubset(set) - возвращает True, если все элементы множества содержатся во втором множестве
issuperset(set) - возвращает True, если все элементы второго множества содержатся в первом множестве
symmetric_difference(set) - или оператор ^ возвращает симметричную разность множеств (элементы, которые есть только в одном из множеств)
symmetric_difference_update(set) - или оператор ^= обновляет множество, оставляя только элементы, которые есть только в одном из множеств
union(set) - или оператор | возвращает объединение множеств
update(set) - или оператор |= обновляет множество, добавляя элементы из другого множества
"""

new_set = {}  # это не сет, это словарь
new_set = set()

# add - добавляет элемент в множество
new_set.add("хлеб")
new_set.add("хлеб")
new_set.add("хлеб")
new_set.add("коньяк")

print(new_set)

# discard - удаляет элемент из множества, если он там есть
new_set.discard("коньяк")
print(new_set)

my_movies = {"Терминатор", "Матрица", "Начало", "Гладиатор", "Бойцовский клуб", "Престиж", "Интерстеллар"}
wife_movies = {"Титаник", "Дневник памяти", "Престиж", "Интерстеллар", "Ла-Ла Ленд", "Гордость и предубеждение"}

# difference - или оператор - возвращает разницу между множествами
print(my_movies - wife_movies) # {'Начало', 'Терминатор', 'Гладиатор', 'Матрица', 'Бойцовский клуб'}

# intersection - или оператор & возвращает пересечение множеств
print(my_movies & wife_movies)  # {'Интерстеллар', 'Престиж'}


# symmetric_difference - или оператор ^ возвращает симметричную разность множеств (элементы, которые есть только в одном из множеств)
print(my_movies ^ wife_movies)
 # {'Матрица', 'Гордость и предубеждение', 'Титаник', 'Дневник памяти', 'Терминатор', 'Гладиатор', 'Ла-Ла Ленд', 'Бойцовский клуб', 'Начало'}

# union - или оператор | возвращает объединение множеств
print(my_movies | wife_movies)
# {'Бойцовский клуб', 'Ла-Ла Ленд', 'Матрица', 'Престиж', 'Дневник памяти', 'Титаник', 'Начало', 'Терминатор', 'Гордость и предубеждение', 'Гладиатор', 'Интерстеллар'}

# isdisjoint - возвращает True, если множества не имеют общих элементов
print(my_movies.isdisjoint(wife_movies))  # False

# Все четные числа от 2 до 10
all_even = {2, 4, 6, 8, 10}

# Четные числа до 6
small_even = {2, 4, 6}

# Проверяем является ли small_even подмножеством all_even
print(small_even.issubset(all_even))  # True

# Проверяем является ли all_even надмножеством small_even
print(all_even.issuperset(small_even))  # True





# update
